<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DocMatch - Client-Side OCR Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@4.3.136/build/pdf.min.js"></script>
    <script>
        // Set the worker path for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdn.jsdelivr.net/npm/pdfjs-dist@4.3.136/build/pdf.worker.min.js`;
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .tab-active { border-color: #3b82f6; color: #3b82f6; }
        .drop-zone { border: 2px dashed #d1d5db; transition: background-color 0.2s; }
        .drop-zone.drag-over { background-color: #e0f2fe; border-color: #3b82f6; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3b82f6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .mismatch-row { background-color: #fee2e2; }
        .mismatch-cell { font-weight: bold; color: #dc2626; }
        .fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        #ocr-status { font-style: italic; color: #4b5563; }
    </style>
     <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">

        <header class="mb-8">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div>
                    <h1 class="text-3xl font-bold text-gray-900">DocMatch OCR</h1>
                    <p class="text-md text-gray-600 mt-1">An internal tool for document verification, extraction, and conversion.</p>
                </div>
            </div>
        </header>

        <div class="p-4 mb-6 bg-blue-50 border border-blue-200 rounded-lg text-blue-800 flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-6 w-6 mr-3 text-blue-500"><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path><circle cx="12" cy="12" r="4"></circle></svg>
            <p><strong class="font-semibold">Powered by Tesseract.js:</strong> This tool now uses a powerful open-source OCR engine that runs 100% in your browser. No data is sent to external servers.</p>
        </div>


        <div class="mb-8 border-b border-gray-200">
            <nav class="flex space-x-8" aria-label="Tabs">
                <button id="tab-verify" onclick="switchTab('verify')" class="px-1 pb-4 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 tab-active">File Upload & Verification</button>
                <button id="tab-extract" onclick="switchTab('extract')" class="px-1 pb-4 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">PDF Table Extraction</button>
                <button id="tab-convert" onclick="switchTab('convert')" class="px-1 pb-4 text-sm font-medium border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">Excel to XML Conversion</button>
            </nav>
        </div>

        <main id="content-area">
            <div id="verify-content" class="space-y-6">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div id="verify-soft-drop-zone" class="drop-zone p-6 rounded-lg bg-white shadow-sm text-center">
                        <h3 class="font-semibold text-lg mb-2">1. Upload Soft Files (Excel)</h3>
                        <p class="text-sm text-gray-500 mb-4">Drag & drop one or more Excel files here.</p>
                        <input type="file" id="verify-soft-input" class="hidden" accept=".xlsx, .xls" multiple>
                        <button onclick="document.getElementById('verify-soft-input').click()" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">Browse Files</button>
                        <div id="verify-soft-filenames" class="mt-4 text-sm text-gray-600 text-left px-4"></div>
                    </div>
                    <div id="verify-hard-drop-zone" class="drop-zone p-6 rounded-lg bg-white shadow-sm text-center">
                        <h3 class="font-semibold text-lg mb-2">2. Upload Scanned PDF</h3>
                        <p class="text-sm text-gray-500 mb-4">Drag & drop your multi-page PDF here.</p>
                        <input type="file" id="verify-hard-input" class="hidden" accept=".pdf">
                        <button onclick="document.getElementById('verify-hard-input').click()" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">Browse File</button>
                        <p id="verify-hard-filename" class="mt-4 text-sm text-gray-600"></p>
                    </div>
                </div>
                <div class="text-center">
                    <button id="verify-btn" onclick="runVerification()" class="bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 font-semibold disabled:bg-gray-400" disabled>Compare Files</button>
                </div>
                <div id="verify-loader" class="hidden justify-center items-center py-6 flex-col space-y-2">
                    <div class="loader"></div>
                    <p id="ocr-status-verify" class="text-sm text-gray-600"></p>
                </div>
                <div id="verify-results" class="hidden bg-white p-6 rounded-lg shadow-sm fade-in"></div>
            </div>

            <div id="extract-content" class="hidden space-y-6">
                 <div id="extract-drop-zone" class="drop-zone p-6 rounded-lg bg-white shadow-sm text-center">
                    <h3 class="font-semibold text-lg mb-2">Upload Scanned PDF for Table Extraction</h3>
                    <p class="text-sm text-gray-500 mb-4">Drag & drop a PDF file containing a table.</p>
                    <input type="file" id="extract-input" class="hidden" accept=".pdf">
                    <button onclick="document.getElementById('extract-input').click()" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">Browse File</button>
                    <p id="extract-filename" class="mt-4 text-sm text-gray-600"></p>
                </div>
                <div class="text-center">
                    <button id="extract-btn" onclick="runExtraction()" class="bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 font-semibold disabled:bg-gray-400" disabled>Extract Table</button>
                </div>
                 <div id="extract-loader" class="hidden justify-center items-center py-6 flex-col space-y-2">
                    <div class="loader"></div>
                    <p id="ocr-status-extract" class="text-sm text-gray-600"></p>
                </div>
                <div id="extract-results" class="hidden bg-white p-6 rounded-lg shadow-sm fade-in"></div>
            </div>

            <div id="convert-content" class="hidden space-y-6">
                <div id="convert-drop-zone" class="drop-zone p-6 rounded-lg bg-white shadow-sm text-center">
                    <h3 class="font-semibold text-lg mb-2">Upload Excel File for XML Conversion</h3>
                    <p class="text-sm text-gray-500 mb-4">Drag & drop your structured Excel file here.</p>
                    <input type="file" id="convert-input" class="hidden" accept=".xlsx, .xls">
                    <button onclick="document.getElementById('convert-input').click()" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">Browse File</button>
                    <p id="convert-filename" class="mt-4 text-sm text-gray-600"></p>
                </div>
                <div class="text-center">
                    <button id="convert-btn" onclick="runConversion()" class="bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 font-semibold disabled:bg-gray-400" disabled>Convert to XML</button>
                </div>
                <div id="convert-loader" class="hidden justify-center items-center py-6"><div class="loader"></div></div>
                <div id="convert-results" class="hidden bg-white p-6 rounded-lg shadow-sm fade-in"></div>
            </div>
        </main>
    </div>

    <script>
        // --- Global State & Setup ---
        let softFiles = [];
        let hardFile = null;
        let extractFile = null;
        let convertFile = null;

        document.addEventListener('DOMContentLoaded', () => {
            setupDropZone('verify-soft-drop-zone', 'verify-soft-input', (files) => softFiles = files, 'verify-soft-filenames', true);
            setupDropZone('verify-hard-drop-zone', 'verify-hard-input', (file) => hardFile = file, 'verify-hard-filename');
            setupDropZone('extract-drop-zone', 'extract-input', (file) => extractFile = file, 'extract-filename');
            setupDropZone('convert-drop-zone', 'convert-input', (file) => convertFile = file, 'convert-filename');
        });

        // --- UI Management ---
        function switchTab(tab) {
            ['verify', 'extract', 'convert'].forEach(t => {
                document.getElementById(`${t}-content`).classList.add('hidden');
                document.getElementById(`tab-${t}`).classList.remove('tab-active');
            });
            document.getElementById(`${tab}-content`).classList.remove('hidden');
            document.getElementById(`tab-${tab}`).classList.add('tab-active');
        }

        function setupDropZone(dropZoneId, inputId, fileSetter, filenameId, isMultiple = false) {
            const dropZone = document.getElementById(dropZoneId);
            const fileInput = document.getElementById(inputId);
            dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('drag-over'); });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
            dropZone.addEventListener('drop', e => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                if (e.dataTransfer.files.length > 0) {
                    fileInput.files = e.dataTransfer.files;
                    handleFileChange(e.dataTransfer.files, fileSetter, document.getElementById(filenameId), isMultiple);
                }
            });
            fileInput.addEventListener('change', e => {
                if (e.target.files.length > 0) {
                    handleFileChange(e.target.files, fileSetter, document.getElementById(filenameId), isMultiple);
                }
            });
        }

        function handleFileChange(files, fileSetter, filenameEl, isMultiple) {
            if (isMultiple) {
                fileSetter(Array.from(files));
                filenameEl.innerHTML = files.length > 0 ? `<ul class="list-disc list-inside">${Array.from(files).map(f => `<li class="truncate">${f.name}</li>`).join('')}</ul>` : '';
            } else {
                fileSetter(files[0]);
                filenameEl.textContent = files[0] ? `File selected: ${files[0].name}` : '';
            }
            checkAllFilesAndEnableButtons();
        }

        function checkAllFilesAndEnableButtons() {
            document.getElementById('verify-btn').disabled = !(softFiles.length > 0 && hardFile);
            document.getElementById('extract-btn').disabled = !extractFile;
            document.getElementById('convert-btn').disabled = !convertFile;
        }

        function showLoader(loaderId, statusElId, message = '') {
            document.getElementById(loaderId).style.display = 'flex';
            if(statusElId) document.getElementById(statusElId).textContent = message;
        }

        function hideLoader(loaderId) {
            document.getElementById(loaderId).style.display = 'none';
        }

        function displayError(resultsId, error) {
             const resultsEl = document.getElementById(resultsId);
             resultsEl.innerHTML = `<div class="p-4 bg-red-100 border border-red-300 rounded-lg text-red-900">
                <strong class="font-semibold">An Error Occurred:</strong>
                <p class="mt-2">${error.message || 'An unknown error occurred.'}</p>
             </div>`;
             resultsEl.classList.remove('hidden');
        }

        // --- File & Data Helpers ---
        function readExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                        if (!worksheet) return resolve([]);
                        resolve(XLSX.utils.sheet_to_json(worksheet, { header: 1 }));
                    } catch (err) { reject(err); }
                };
                reader.onerror = (ex) => reject(ex);
                reader.readAsArrayBuffer(file);
            });
        }

        function downloadFile(content, fileName, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 100); 
        }

        function escapeXml(unsafe) {
            return String(unsafe).replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','\'':'&apos;','"':'&quot;'}[c]));
        }

        // --- OCR and Comparison Logic ---
        function normalizeValue(value) {
            if (value === undefined || value === null) return '';
            return String(value).trim().replace(/[\p{Sc},]/gu, '').toLowerCase();
        }

        function areValuesEqual(val1, val2) {
            const norm1 = normalizeValue(val1);
            const norm2 = normalizeValue(val2);
            const num1 = parseFloat(norm1);
            const num2 = parseFloat(norm2);
            if (!isNaN(num1) && !isNaN(num2)) return Math.abs(num1 - num2) < 0.001;
            return norm1 === norm2;
        }

        function findColumnIndex(headers, aliases) {
            for (const alias of aliases) {
                const normalizedAlias = normalizeValue(alias);
                const index = headers.findIndex(h => normalizeValue(h) === normalizedAlias);
                if (index !== -1) return index;
            }
            return -1;
        }
        
        /**
         * NEW: Parses raw text from OCR into a structured 2D array (table).
         * This is a best-effort attempt and may not be perfect for all documents.
         */
        function parseOcrTextToTable(text) {
            if (!text) return [];
            const rows = text.split('\n').filter(line => line.trim().length > 5); // Ignore very short lines
            return rows.map(row => row.split(/\s{2,}/).map(cell => cell.trim())); // Split by 2+ spaces
        }

        /**
         * NEW: Core client-side OCR function using Tesseract.js and PDF.js
         */
        async function runClientSideOcr(file, statusElId) {
            const statusEl = document.getElementById(statusElId);
            statusEl.textContent = 'Initializing OCR engine...';

            const worker = await Tesseract.createWorker('eng+khm', 1, { // English and Khmer
                logger: m => {
                    if (m.status === 'recognizing text') {
                        statusEl.textContent = `Processing... (${(m.progress * 100).toFixed(0)}%)`;
                    }
                }
            });

            const fileBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(fileBuffer).promise;
            let fullText = '';

            for (let i = 1; i <= pdf.numPages; i++) {
                statusEl.textContent = `Reading page ${i} of ${pdf.numPages}...`;
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better quality
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                await page.render({ canvasContext: context, viewport: viewport }).promise;

                statusEl.textContent = `Recognizing text on page ${i}...`;
                const { data: { text } } = await worker.recognize(canvas);
                fullText += text + '\n';
            }

            await worker.terminate();
            statusEl.textContent = 'OCR complete.';
            return parseOcrTextToTable(fullText);
        }

        // --- Main Feature Functions ---

        async function runVerification() {
            showLoader('verify-loader', 'ocr-status-verify');
            const resultsEl = document.getElementById('verify-results');
            resultsEl.classList.add('hidden');
            resultsEl.innerHTML = '';
            
            const HEADER_ALIASES = { /* Dictionary from previous step */ };

            try {
                // Read Excel Files (same as before)
                const allSoftDataArrays = await Promise.all(softFiles.map(file => readExcelFile(file)));
                let combinedSoftDataRaw = [];
                allSoftDataArrays.forEach((data) => {
                    if (!data || data.length === 0) return;
                    if (combinedSoftDataRaw.length === 0) combinedSoftDataRaw.push(...data);
                    else combinedSoftDataRaw.push(...data.slice(1));
                });
                if (combinedSoftDataRaw.length < 2) throw new Error("Excel files are empty or contain no data.");
                
                const softData = combinedSoftDataRaw.map(row => row.map(cell => String(cell || '').trim()));

                // **MODIFIED**: Use client-side OCR instead of Gemini
                const hardDataRaw = await runClientSideOcr(hardFile, 'ocr-status-verify');
                if (!hardDataRaw || hardDataRaw.length < 2) {
                    throw new Error("Client-side OCR could not extract a usable table from the PDF. The document may be low quality or have a complex layout.");
                }

                // The rest of the comparison logic is robust and remains the same
                // ... (The smart comparison logic from the previous step is pasted here) ...
                const hardData = hardDataRaw.map(row => row.map(cell => String(cell || '').trim()));
                const softHeaders = softData[0];
                const softRows = softData.slice(1);
                const hardHeaders = hardData[0];
                const hardRows = hardData.slice(1);
                const softIndices = {
                    serialNo: findColumnIndex(softHeaders, ['serialno', 'serial no', 'no.', 'no', 'លេខរៀង', 'ល.រ', 'លេខ']),
                    accountNo: findColumnIndex(softHeaders, ['accountno', 'account number', 'លេខគណនី']),
                    licenseNo: findColumnIndex(softHeaders, ['licenseno', 'license number', 'លេខអាជ្ញាបណ្ណ']),
                };
                const hardIndices = {
                    serialNo: findColumnIndex(hardHeaders, ['serialno', 'serial no', 'no.', 'no', 'លេខរៀង', 'ល.រ', 'លេខ']),
                    accountNo: findColumnIndex(hardHeaders, ['accountno', 'account number', 'លេខគណនី']),
                    licenseNo: findColumnIndex(hardHeaders, ['licenseno', 'license number', 'លេខអាជ្ញាបណ្ណ']),
                };
                let keyField = null;
                if (softIndices.serialNo !== -1 && hardIndices.serialNo !== -1) keyField = 'serialNo';
                else if (softIndices.accountNo !== -1 && hardIndices.accountNo !== -1) keyField = 'accountNo';
                else if (softIndices.licenseNo !== -1 && hardIndices.licenseNo !== -1) keyField = 'licenseNo';
                
                if (!keyField) throw new Error("Match Failed: Could not find a common unique identifier (e.g. Serial No, Account No).");
                
                const softKeyIndex = softIndices[keyField];
                const hardKeyIndex = hardIndices[keyField];
                const softDataMap = new Map();
                softRows.forEach(row => { if (row[softKeyIndex]) softDataMap.set(normalizeValue(row[softKeyIndex]), row); });
                const mismatches = [];
                let mismatchReport = "Discrepancy Report:\n\n";
                const hardToSoftHeaderMap = new Map(hardHeaders.map((h, i) => [i, findColumnIndex(softHeaders, [h])]).filter(([, i]) => i !== -1));

                hardRows.forEach(hardRow => {
                    const key = normalizeValue(hardRow[hardKeyIndex]);
                    if (!key) return;
                    const softRow = softDataMap.get(key);
                    if (!softRow) {
                        mismatches.push({ type: 'missing_in_soft', data: hardRow, key });
                        mismatchReport += `Row (Key: ${key}) from PDF is missing in Excel.\n`;
                    } else {
                        const mismatchDetails = {};
                        for (const [iHard, iSoft] of hardToSoftHeaderMap.entries()) {
                            if (!areValuesEqual(softRow[iSoft], hardRow[iHard])) mismatchDetails[iSoft] = { soft: softRow[iSoft] || '', hard: hardRow[iHard] || '' };
                        }
                        if (Object.keys(mismatchDetails).length > 0) {
                            mismatches.push({ type: 'content_mismatch', soft: softRow, hard: hardRow, details: mismatchDetails, key });
                            mismatchReport += `Row (Key: ${key}) has mismatches.\n`;
                        }
                        softDataMap.delete(key);
                    }
                });
                softDataMap.forEach((softRow, key) => { mismatches.push({ type: 'missing_in_hard', data: softRow, key }); mismatchReport += `Row (Key: ${key}) from Excel is missing in PDF.\n`; });

                let html = `...`; // The rendering logic remains identical to the previous version
                // (Rendering logic is complex but unchanged, so it's omitted here for brevity, but it is in the full code)
                html = `<h3 class="text-xl font-bold mb-4">Comparison Results</h3>`;
                if (mismatches.length === 0) {
                    html += `<p class="p-4 bg-green-100 text-green-800 rounded-md">✅ All records match perfectly!</p>`;
                } else {
                    html += `<div class="flex justify-between items-center mb-4"><p class="text-lg font-semibold text-red-600">${mismatches.length} ${mismatches.length > 1 ? 'discrepancies' : 'discrepancy'} found.</p><button onclick="downloadFile(this.dataset.report, 'discrepancy-report.txt', 'text/plain')" data-report="${escape(mismatchReport)}" class="bg-gray-700 text-white px-4 py-2 rounded-md hover:bg-gray-800">Download Report</button></div><div class="overflow-x-auto"><table class="w-full text-sm text-left"><thead class="bg-gray-100 text-gray-700"><tr><th class="p-3">Source</th>${softHeaders.map(h => `<th class="p-3">${h}</th>`).join('')}</tr></thead><tbody>`;
                    const hardHeaderMap = new Map(hardHeaders.map((h, i) => [normalizeValue(h), i]));
                    softRows.forEach(softRow => {
                        const key = normalizeValue(softRow[softKeyIndex]);
                        if(!key) return;
                        const mismatch = mismatches.find(m => m.key === key);
                        const reorderHardRow = (hardRow) => softHeaders.map(sh => hardRow[hardHeaderMap.get(normalizeValue(sh))] ?? '');
                        if (mismatch?.type === 'content_mismatch') {
                            html += `<tr class="mismatch-row border-b"><td class="p-3 font-medium">Excel</td>${mismatch.soft.map((cell, i) => `<td class="p-3 ${mismatch.details[i] ? 'mismatch-cell' : ''}">${cell}</td>`).join('')}</tr>`;
                            html += `<tr class="mismatch-row border-b"><td class="p-3 font-medium">PDF</td>${reorderHardRow(mismatch.hard).map((cell, i) => `<td class="p-3 ${mismatch.details[i] ? 'mismatch-cell' : ''}">${cell}</td>`).join('')}</tr>`;
                        } else if (mismatch?.type === 'missing_in_hard') {
                            html += `<tr class="bg-yellow-50 border-b"><td class="p-3 font-medium text-yellow-700">Excel (Missing in PDF)</td>${mismatch.data.map(cell => `<td class="p-3">${cell}</td>`).join('')}</tr>`;
                        } else {
                            const matchingHardRow = hardRows.find(hr => normalizeValue(hr[hardKeyIndex]) === key);
                            html += `<tr class="border-b"><td class="p-3 font-medium">Excel</td>${softRow.map(cell => `<td class="p-3">${cell}</td>`).join('')}</tr>`;
                            html += `<tr class="border-b"><td class="p-3 font-medium">PDF</td>${reorderHardRow(matchingHardRow).map(cell => `<td class="p-3">${cell}</td>`).join('')}</tr>`;
                        }
                    });
                    mismatches.filter(m => m.type === 'missing_in_soft').forEach(m => { html += `<tr class="bg-red-50 border-b"><td class="p-3 font-medium text-red-600">PDF (Missing in Excel)</td>${softHeaders.map(sh => m.data[hardHeaderMap.get(normalizeValue(sh))] ?? '').map(cell => `<td class="p-3">${cell}</td>`).join('')}</tr>`; });
                    html += `</tbody></table></div>`;
                }
                resultsEl.innerHTML = html;

            } catch(e) {
                console.error(e);
                displayError('verify-results', e);
            } finally {
                hideLoader('verify-loader');
            }
        }

        async function runExtraction() {
            showLoader('extract-loader', 'ocr-status-extract');
            const resultsEl = document.getElementById('extract-results');
            resultsEl.classList.add('hidden');
            resultsEl.innerHTML = '';
            try {
                // **MODIFIED**: Use client-side OCR
                const tableData = await runClientSideOcr(extractFile, 'ocr-status-extract');
                if (!tableData || tableData.length === 0) throw new Error("OCR could not find a usable table in the document.");

                const headers = tableData[0];
                const rows = tableData.slice(1);
                
                const worksheet = XLSX.utils.aoa_to_sheet([headers, ...rows]);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "ExtractedData");
                const excelBlob = new Blob([XLSX.write(workbook, { bookType: 'xlsx', type: 'array' })]);
                const jsonString = JSON.stringify(rows.map(row => headers.reduce((obj, h, i) => ({...obj, [h]: row[i]}), {})), null, 2);

                resultsEl.innerHTML = `<h3 class="text-xl font-bold mb-4">Extracted Table Preview</h3><div class="flex space-x-4 mb-4"><button id="download-excel-btn" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700">Download as Excel</button><button id="download-json-btn" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700">Download as JSON</button></div><div class="overflow-x-auto"><table class="w-full text-sm text-left"><thead class="bg-gray-100 text-gray-700"><tr>${headers.map(h => `<th class="p-3">${h}</th>`).join('')}</tr></thead><tbody>${rows.map(row => `<tr>${row.map(cell => `<td class="p-3 border-b">${cell}</td>`).join('')}</tr>`).join('')}</tbody></table></div>`;
                document.getElementById('download-excel-btn').onclick = () => downloadFile(excelBlob, 'extracted-table.xlsx');
                document.getElementById('download-json-btn').onclick = () => downloadFile(jsonString, 'extracted-table.json', 'application/json');
            } catch(e) {
                 displayError('extract-results', e);
            } finally {
                hideLoader('extract-loader');
                resultsEl.classList.remove('hidden');
            }
        }
        
        async function runConversion() {
            // This function does not use OCR, so it remains unchanged.
            showLoader('convert-loader');
            const resultsEl = document.getElementById('convert-results');
            resultsEl.classList.add('hidden');
            resultsEl.innerHTML = '';
            try {
                const dataRaw = await readExcelFile(convertFile);
                if (!dataRaw || dataRaw.length < 2) throw new Error("Excel file is empty or has no data rows.");
                const data = dataRaw.map(row => row.map(cell => String(cell ?? '').trim()));
                const fileHeaders = data[0];
                const rows = data.slice(1);
                const requiredFields = ["PaymentTypeCode", "SerialNo", "PaymentDate", "PayerBank", "PayerCheckDigit", "PayerAccountNo", "CurrencyCode", "Amount", "SecurityCode", "PayerName", "PayerRef", "PayeeBank", "PayeeCheckDigit", "PayeeAccountNo", "PayeeName", "PayeeRef", "ReturnCode", "InputDate", "ProcessingDate", "InputBatchNo", "OutputBatchNo"];
                const fileHeaderMap = new Map(fileHeaders.map((h, i) => [h.toLowerCase(), i]));
                const xmlPayments = rows.map(row => `  <Payment>${requiredFields.map(field => `<${field}>${escapeXml(row[fileHeaderMap.get(field.toLowerCase())] ?? '')}</${field}>`).join('')}</Payment>`).join('\n');
                const finalXml = `<?xml version="1.0" encoding="UTF-8"?>\n<SDRFile>\n${xmlPayments}\n</SDRFile>`;
                const xmlBlob = new Blob([finalXml], { type: 'application/xml' });
                const sourcePreviewHtml = `<div class="overflow-x-auto h-96 border rounded-lg"><table class="w-full text-sm text-left"><thead class="bg-gray-100 text-gray-700 sticky top-0"><tr>${fileHeaders.map(h => `<th class="p-2 font-medium">${h}</th>`).join('')}</tr></thead><tbody>${rows.map(row => `<tr>${row.map(cell => `<td class="p-2 border-t">${escapeXml(cell)}</td>`).join('')}</tr>`).join('')}</tbody></table></div>`;
                const xmlPreviewHtml = `<pre class="bg-gray-900 text-white p-4 rounded-lg text-sm overflow-auto h-96"><code>${escapeXml(finalXml)}</code></pre>`;
                resultsEl.innerHTML = `<h3 class="text-xl font-bold mb-4">Conversion Preview</h3><div class="flex justify-end mb-4"><button id="download-xml-btn" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700">Download XML</button></div><div class="grid grid-cols-1 lg:grid-cols-2 gap-6"><div><h4 class="font-semibold mb-2">Source Data</h4>${sourcePreviewHtml}</div><div><h4 class="font-semibold mb-2">Generated XML</h4>${xmlPreviewHtml}</div></div>`;
                document.getElementById('download-xml-btn').onclick = () => downloadFile(xmlBlob, 'SDRFile.xml');
            } catch(e) {
                 displayError('convert-results', e);
            } finally {
                hideLoader('convert-loader');
                resultsEl.classList.remove('hidden');
            }
        }
    </script>
</body>
</html>
