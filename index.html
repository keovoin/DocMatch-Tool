<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DocMatch Tool</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
  <style>
    body { padding:18px; }
    .dropzone { min-height:140px; border:2px dashed #0d6efd; border-radius:6px; display:flex; align-items:center; justify-content:center; cursor:pointer; }
    .file-card { border:1px solid #e9ecef; border-radius:6px; padding:10px; margin-bottom:8px; }
    .xml-preview { white-space:pre-wrap; word-break:break-word; background:#0b1220; color:#e6eef8; padding:12px; border-radius:6px; max-height:420px; overflow:auto; }
    .small-mono { font-family: monospace; font-size:.85rem; color:#333; }
  </style>
</head>
<body>
  <h1>DocMatch Tool</h1>

  <div class="row">
    <div class="col-lg-6">
      <h4>Upload & Verification</h4>

      <div id="dropzone" class="dropzone mb-3">Drop files here or click to upload</div>
      <input id="fileInput" type="file" multiple hidden accept=".pdf,.png,.jpg,.jpeg,.tiff,.tif,.xlsx,.xls,.csv" />

      <div id="fileList" class="mb-3"><div class="text-muted">No files selected</div></div>

      <div class="mb-3">
        <label for="processMode" class="form-label">Mode</label>
        <select id="processMode" class="form-select">
          <option value="verify">Verify (Excel ↔ PDF)</option>
          <option value="convert">Convert Excel → XML</option>
        </select>
      </div>

      <div class="d-flex gap-2 mb-3">
        <button id="startBtn" class="btn btn-primary">Start</button>
        <button id="clearBtn" class="btn btn-outline-secondary">Clear All</button>
      </div>

      <div id="loader" class="mt-3 hidden">Processing... please wait.</div>
      <div id="results" class="mt-3 hidden"></div>
    </div>

    <div class="col-lg-6">
      <h4>Output / Logs</h4>
      <div id="output" style="white-space:pre-wrap;background:#f8f9fa;padding:10px;border-radius:6px;min-height:420px"></div>
    </div>
  </div>

<script>
  // Element refs
  const dropzone = document.getElementById('dropzone');
  const fileInput = document.getElementById('fileInput');
  const fileList = document.getElementById('fileList');
  const startBtn = document.getElementById('startBtn');
  const clearBtn = document.getElementById('clearBtn');
  const output = document.getElementById('output');
  const processMode = document.getElementById('processMode');
  const loader = document.getElementById('loader');
  const results = document.getElementById('results');

  // File model
  let files = []; // { id, file, type, size, status, checksum, pages, addedAt, needsVerification, error }
  const MAX_FILE_SIZE = 50 * 1024 * 1024;

  // Utilities
  function genId(){ return Date.now().toString(36) + Math.random().toString(36).slice(2,8); }
  function escapeXml(unsafe){ if(unsafe===undefined||unsafe===null) return ''; if(typeof unsafe !== 'string') unsafe = String(unsafe); return unsafe.replace(/[<>&'"]/g,c=>({'<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;', '"':'&quot;'}[c])); }
  function detectType(file){ const n=(file.name||'').toLowerCase(); if(file.type==='application/pdf' || n.endsWith('.pdf')) return 'pdf'; if(n.endsWith('.xlsx')||n.endsWith('.xls')) return 'excel'; if(n.endsWith('.csv')||file.type==='text/csv') return 'csv'; if((file.type&&file.type.startsWith('image/'))||n.match(/\.(png|jpg|jpeg|tiff|tif)$/)) return 'image'; return 'unknown'; }
  async function computeSha256(file){ try{ const buf = await file.arrayBuffer(); const hashBuffer = await crypto.subtle.digest('SHA-256', buf); const hashArray = Array.from(new Uint8Array(hashBuffer)); return hashArray.map(b=>b.toString(16).padStart(2,'0')).join(''); }catch(e){ return null; } }

  // Read Excel helper (SheetJS optional)
  async function readExcelFile(file) {
    if (typeof XLSX !== 'undefined') {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const firstSheet = workbook.SheetNames[0];
            const rows = XLSX.utils.sheet_to_json(workbook.Sheets[firstSheet], { header: 1, defval: '' });
            resolve(rows);
          } catch(ex) { reject(ex); }
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    } else {
      if (file.type === 'text/csv' || file.name.toLowerCase().endsWith('.csv')) {
        const text = await file.text();
        const rows = text.split(/\r?\n/).filter(r => r.trim() !== '').map(r => r.split(',').map(c => c.trim()));
        return rows;
      }
      throw new Error('No XLSX parser available and file is not CSV. To enable XLSX in-browser include SheetJS or upload CSV.');
    }
  }

  // --- Safe, lazy detection function (does NOT throw on failure) ---
  function detectAccountAndAmountIndices(headersLeft, rowsLeft, headersRight, rowsRight) {
    function trimStr(v){ return v===undefined||v===null ? '' : String(v).trim(); }
    function findHeaderIndexByCandidates(headers, candidates){
      const norm = (headers||[]).map(h => trimStr(h).toLowerCase());
      for (const c of candidates) {
        const idx = norm.indexOf(c.toLowerCase());
        if (idx !== -1) return idx;
      }
      for (let i=0;i<norm.length;i++){
        for (const c of candidates) {
          if (norm[i].includes(c.toLowerCase())) return i;
        }
      }
      return -1;
    }
    function looksLikeAccountColumn(rows, colIndex){
      if (colIndex < 0) return 0;
      let score = 0;
      for (let r=0;r<Math.min(rows.length,20);r++){
        const v = String((rows[r]||[])[colIndex]||'').trim();
        if (!v) continue;
        if (/\d/.test(v)) score += 2;
        try { if (/\p{L}/u.test(v)) score += 1; } catch(e) { if (/[A-Za-z]/.test(v)) score += 1; }
        if (/[ \-]/.test(v)) score += 0.5;
        if (/^\d{6,}/.test(v)) score += 0.5;
      }
      return score;
    }
    function looksLikeAmountColumn(rows, colIndex){
      if (colIndex < 0) return 0;
      let score = 0;
      for (let r=0;r<Math.min(rows.length,20);r++){
        const v = String((rows[r]||[])[colIndex]||'').trim();
        if (!v) continue;
        let s = v.replace(/[\u00A0\s,]/g,'');
        try { s = s.replace(/[\p{Sc}]/gu,''); } catch(e) { s = s.replace(/[$€£¥฿¢]/g,''); }
        if (/^-?\d+(\.\d+)?$/.test(s)) score += 2;
        if (/^\d+[,\.]\d{2}$/.test(v)) score += 1.5;
        if (/\d/.test(v)) score += 0.5;
        if (v.includes('.')) score += 0.2;
      }
      return score;
    }

    const accountCandidatesEn = ['account number','accountnumber','accountno','account','acct','acct no','bank account','account #'];
    const amountCandidatesEn  = ['amount','amount transfer ($)','amount transfer','amt','transfer amount','value','total','amount ($)'];
    const accountCandidatesKh = ['លេខគណនី','គណនី','លេខ គណនី','លេខគណនី','លេខ​គណនី'];
    const amountCandidatesKh  = ['ចំនួន','ចំនួនទឹកប្រាក់','ទឹកប្រាក់','ចំនួនទឹកប្រាក់($)','តម្លៃ'];

    const accountCandidates = accountCandidatesEn.concat(accountCandidatesKh);
    const amountCandidates  = amountCandidatesEn.concat(amountCandidatesKh);

    headersLeft  = headersLeft  || [];
    headersRight = headersRight || [];
    rowsLeft     = rowsLeft     || [];
    rowsRight    = rowsRight    || [];

    let accIdxLeft  = findHeaderIndexByCandidates(headersLeft, accountCandidates);
    let amtIdxLeft  = findHeaderIndexByCandidates(headersLeft, amountCandidates);
    let accIdxRight = findHeaderIndexByCandidates(headersRight, accountCandidates);
    let amtIdxRight = findHeaderIndexByCandidates(headersRight, amountCandidates);

    function pickBestIndexByScorer(headers, rows, scorer) {
      let best = -1, bestScore = 0;
      for (let c=0;c<(headers||[]).length;c++){
        const s = scorer(rows, c);
        if (s > bestScore) { bestScore = s; best = c; }
      }
      return best;
    }

    if (accIdxLeft === -1) accIdxLeft = pickBestIndexByScorer(headersLeft, rowsLeft, looksLikeAccountColumn);
    if (amtIdxLeft === -1) amtIdxLeft = pickBestIndexByScorer(headersLeft, rowsLeft, looksLikeAmountColumn);
    if (accIdxRight === -1) accIdxRight = pickBestIndexByScorer(headersRight, rowsRight, looksLikeAccountColumn);
    if (amtIdxRight === -1) amtIdxRight = pickBestIndexByScorer(headersRight, rowsRight, looksLikeAmountColumn);

    const plausibleAccount = (accIdxLeft !== -1) && (accIdxRight !== -1);
    const plausibleAmount  = (amtIdxLeft !== -1) && (amtIdxRight !== -1);

    if (!plausibleAccount || !plausibleAmount) {
      return {
        ok: false,
        diagnostics: { accIdxLeft, amtIdxLeft, accIdxRight, amtIdxRight, headersLeft, headersRight }
      };
    }

    return { ok: true, accIdxLeft, amtIdxLeft, accIdxRight, amtIdxRight };
  }

  // Amount normalization + compare
  function normalizeAmountToNumber(value) {
    if (value === undefined || value === null) return NaN;
    let s = String(value).trim();
    s = s.replace(/[\u00A0\s]/g, '');
    try { s = s.replace(/[\p{Sc}]/gu, ''); } catch(e) { s = s.replace(/[$€£¥฿¢]/g, ''); }
    if (/^\d{1,3}(?:[\.\s]\d{3})+,\d+$/.test(s)) { s = s.replace(/\./g, '').replace(',', '.'); }
    else if (/^\d{1,3}(?:,\d{3})+\.\d+$/.test(s)) { s = s.replace(/,/g, ''); }
    else { s = s.replace(/[, ](?=\d{3}(\D|$))/g, ''); }
    const dots = (s.match(/\./g) || []).length;
    if (dots > 1) { const parts = s.split('.'); const dec = parts.pop(); s = parts.join('') + '.' + dec; }
    s = s.replace(/[^\d.\-]/g, '');
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }
  function compareAmounts(a,b,eps=0.0001){ const na = normalizeAmountToNumber(a); const nb = normalizeAmountToNumber(b); if (Number.isNaN(na) || Number.isNaN(nb)) return false; return Math.abs(na-nb) <= eps; }

  // Prepare SerialNo if missing
  function findSerialHeaderIndex(headers) {
    const norm = (headers||[]).map(h => (h||'').toString().trim().toLowerCase());
    const candidates = ['serialno','serial','serial_no','serial no','sno','s/n','no','number','id','ref','refno'];
    for (const c of candidates) { const idx = norm.indexOf(c); if (idx !== -1) return idx; }
    for (let i=0;i<norm.length;i++) if (norm[i].includes('serial')||norm[i].includes('sno')||norm[i]==='no') return i;
    return -1;
  }
  function prepareSerialColumns(leftHeaders,leftRows,rightHeaders,rightRows) {
    const leftIdx = findSerialHeaderIndex(leftHeaders);
    const rightIdx = findSerialHeaderIndex(rightHeaders);
    const lRows = leftRows.map(r=>r.slice());
    const rRows = rightRows.map(r=>r.slice());
    const lHeaders = leftHeaders.slice();
    const rHeaders = rightHeaders.slice();
    let lIdx = leftIdx, rIdx = rightIdx;
    if (lIdx === -1) { lHeaders.push('SerialNo'); lIdx = lHeaders.length-1; for (let i=0;i<lRows.length;i++) lRows[i].push(String(i+1)); }
    if (rIdx === -1) { rHeaders.push('SerialNo'); rIdx = rHeaders.length-1; for (let i=0;i<rRows.length;i++) rRows[i].push(String(i+1)); }
    return { leftHeaders:lHeaders, rightHeaders:rHeaders, leftRows:lRows, rightRows:rRows, leftSerialIndex:lIdx, rightSerialIndex:rIdx };
  }

  // File upload handlers
  dropzone.addEventListener('click', () => fileInput.click());
  dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.style.background = '#e9f5ff'; });
  dropzone.addEventListener('dragleave', () => { dropzone.style.background = ''; });
  dropzone.addEventListener('drop', (e) => { e.preventDefault(); dropzone.style.background = ''; handleFiles(e.dataTransfer.files); });
  fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
  clearBtn.addEventListener('click', () => { files = []; renderFileList(); results.innerHTML=''; results.classList.add('hidden'); output.textContent=''; });

  async function handleFiles(selectedFiles) {
    for (let i=0;i<selectedFiles.length;i++){
      const f = selectedFiles[i];
      if (f.size > MAX_FILE_SIZE) {
        files.push({ id: genId(), file: f, type: detectType(f), size: f.size, status:'error', checksum:null, pages:null, addedAt:new Date().toISOString(), needsVerification:false, error:'File too large' });
        continue;
      }
      const item = { id: genId(), file: f, type: detectType(f), size: f.size, status:'pending', checksum:null, pages:null, addedAt:new Date().toISOString(), needsVerification:false };
      computeSha256(f).then(s => { item.checksum = s; renderFileList(); }).catch(()=>{});
      // optional pdf.js page count:
      if (item.type === 'pdf' && typeof pdfjsLib !== 'undefined' && pdfjsLib.getDocument) {
        try { const ab = await f.arrayBuffer(); const pdf = await pdfjsLib.getDocument({ data: ab }).promise; item.pages = pdf.numPages; } catch(e){}
      }
      files.push(item);
    }
    renderFileList();
  }

  function renderFileList() {
    fileList.innerHTML = '';
    if (files.length === 0) { fileList.innerHTML = '<div class="text-muted">No files selected</div>'; return; }
    files.forEach(it => {
      const sizeKb = Math.round(it.size/1024);
      const div = document.createElement('div');
      div.className = 'file-card d-flex justify-content-between';
      div.innerHTML = `
        <div style="max-width:70%">
          <div><strong>${escapeXml(it.file.name)}</strong> <span class="small text-muted">${escapeXml(it.type)}</span></div>
          <div class="small text-muted">${sizeKb} KB • Added ${new Date(it.addedAt).toLocaleString()}</div>
          ${it.pages ? `<div class="small">Pages: ${it.pages}</div>` : ''}
          ${it.checksum ? `<div class="small-mono">SHA256: ${it.checksum.slice(0,16)}...</div>` : ''}
          ${it.error ? `<div class="text-danger small">${escapeXml(it.error)}</div>` : ''}
        </div>
        <div class="text-end">
          <button data-id="${it.id}" class="btn btn-sm btn-outline-secondary viewBtn mb-1">View</button>
          <button data-id="${it.id}" class="btn btn-sm btn-outline-warning markBtn mb-1">${it.needsVerification ? 'Unmark' : 'Mark'}</button>
          <button data-id="${it.id}" class="btn btn-sm btn-danger removeBtn">Remove</button>
        </div>
      `;
      fileList.appendChild(div);
    });

    fileList.querySelectorAll('.removeBtn').forEach(b => b.addEventListener('click', (e) => {
      const id = e.currentTarget.getAttribute('data-id');
      const idx = files.findIndex(x => x.id === id);
      if (idx > -1) files.splice(idx,1);
      renderFileList();
    }));
    fileList.querySelectorAll('.markBtn').forEach(b => b.addEventListener('click', (e) => {
      const id = e.currentTarget.getAttribute('data-id'); const it = files.find(x=>x.id===id); if(!it) return; it.needsVerification = !it.needsVerification; renderFileList();
    }));
    fileList.querySelectorAll('.viewBtn').forEach(b => b.addEventListener('click', (e) => {
      const id = e.currentTarget.getAttribute('data-id'); const it = files.find(x=>x.id===id); if(!it) return; const url = URL.createObjectURL(it.file); window.open(url,'_blank');
    }));
  }

  function downloadBlob(blob, filename) { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }

  // Matching (Excel rows vs PDF rows) - uses detectAccountAndAmountIndices and prepares SerialNo
  function matchSources(headersA, rowsA, headersB, rowsB) {
    const detect = detectAccountAndAmountIndices(headersA, rowsA, headersB, rowsB);
    if (!detect.ok) return { ok:false, diagnostics: detect.diagnostics };

    const accIdxA = detect.accIdxLeft, amtIdxA = detect.amtIdxLeft, accIdxB = detect.accIdxRight, amtIdxB = detect.amtIdxRight;

    const prep = prepareSerialColumns(headersA, rowsA, headersB, rowsB);
    const Lrows = prep.leftRows, Rrows = prep.rightRows, LserialIdx = prep.leftSerialIndex, RserialIdx = prep.rightSerialIndex;

    // Build lookup by right serial
    const rightBySerial = new Map();
    for (let j=0;j<Rrows.length;j++){
      const key = (Rrows[j][RserialIdx]||'').toString().trim();
      if (!rightBySerial.has(key)) rightBySerial.set(key, []);
      rightBySerial.get(key).push({ row: Rrows[j], index: j });
    }

    const matches = [], unmatchedLeft = [], unmatchedRightUsed = new Set();

    for (let i=0;i<Lrows.length;i++){
      const Lrow = Lrows[i];
      const serialKey = (Lrow[LserialIdx]||'').toString().trim();
      let matched = false;

      // 1) serial match
      if (serialKey !== '' && rightBySerial.has(serialKey)) {
        const cands = rightBySerial.get(serialKey);
        let chosen = null;
        for (const c of cands) {
          const rAmt = Rrows[c.index][amtIdxB];
          const lAmt = Lrow[amtIdxA];
          if (amtIdxA >=0 && amtIdxB >=0 && compareAmounts(lAmt, rAmt)) { chosen = c; break; }
        }
        if (!chosen) chosen = cands.find(c => !unmatchedRightUsed.has(c.index)) || cands[0];
        matches.push({ leftIndex:i, rightIndex:chosen.index, leftRow:Lrow, rightRow:chosen.row, reason:'serial' });
        unmatchedRightUsed.add(chosen.index);
        matched = true;
      }

      // 2) fuzzy by account+amount (account exact if present)
      if (!matched) {
        const lAcc = accIdxA >= 0 ? String(Lrow[accIdxA] || '').replace(/\s+/g,'') : '';
        const lAmt = amtIdxA >= 0 ? Lrow[amtIdxA] : '';
        let bestCandidate = null;
        for (let j=0;j<Rrows.length;j++){
          if (unmatchedRightUsed.has(j)) continue;
          const Rrow = Rrows[j];
          const rAcc = accIdxB >= 0 ? String(Rrow[accIdxB] || '').replace(/\s+/g,'') : '';
          const rAmt = amtIdxB >= 0 ? Rrow[amtIdxB] : '';
          const accMatch = lAcc && rAcc ? (lAcc === rAcc) : true;
          const amtMatch = (amtIdxA >= 0 && amtIdxB >= 0) ? compareAmounts(lAmt, rAmt) : true;
          if (accMatch && amtMatch) { bestCandidate = { index:j, row:Rrow }; break; }
        }
        if (bestCandidate) { matches.push({ leftIndex:i, rightIndex:bestCandidate.index, leftRow:Lrow, rightRow:bestCandidate.row, reason:'fuzzy' }); unmatchedRightUsed.add(bestCandidate.index); matched = true; }
      }

      if (!matched) unmatchedLeft.push({ index:i, row:Lrow });
    }

    const unmatchedRight = [];
    for (let j=0;j<Rrows.length;j++) if (!unmatchedRightUsed.has(j)) unmatchedRight.push({ index:j, row:Rrows[j] });

    return { ok:true, matches, unmatchedLeft, unmatchedRight };
  }

  // Start button handler
  startBtn.addEventListener('click', async () => {
    results.classList.add('hidden'); results.innerHTML=''; output.textContent=''; loader.classList.remove('hidden');
    try {
      const allowed = files.filter(f => !f.needsVerification && f.status !== 'error');
      if (allowed.length === 0) throw new Error('No files available for processing.');

      if (processMode.value === 'convert') {
        const excelItem = allowed.find(x => x.type === 'excel' || x.file.name.toLowerCase().endsWith('.csv') || x.file.name.toLowerCase().endsWith('.xlsx') || x.file.name.toLowerCase().endsWith('.xls'));
        if (!excelItem) throw new Error('No Excel/CSV file found for conversion.');
        const dataRaw = await readExcelFile(excelItem.file);
        if (!dataRaw || dataRaw.length < 2) throw new Error('Excel file must contain a header and at least one data row.');
        const data = dataRaw.map(row => row.map(cell => String(cell || '').trim()));
        const headers = data[0];
        const rows = data.slice(1);
        const requiredFields = ["PaymentTypeCode","SerialNo","PaymentDate","PayerBank","PayerCheckDigit","PayerAccountNo","CurrencyCode","Amount","SecurityCode","PayerName","PayerRef","PayeeBank","PayeeCheckDigit","PayeeAccountNo","PayeeName","PayeeRef","ReturnCode","InputDate","ProcessingDate","InputBatchNo","OutputBatchNo"];
        const headerMap = new Map(headers.map((h,i)=>[String(h||'').trim().toLowerCase(), i]));
        const xmlPayments = rows.map(row => {
          let p = '  <Payment>\n';
          requiredFields.forEach(field => {
            const idx = headerMap.get(field.toLowerCase());
            const value = (typeof idx !== 'undefined' && row[idx] !== undefined) ? row[idx] : '';
            p += `    <${field}>${escapeXml(value)}</${field}>\n`;
          });
          p += '  </Payment>';
          return p;
        }).join('\n');
        const finalXml = `<?xml version="1.0" encoding="UTF-8"?>\n<SDRFile>\n${xmlPayments}\n</SDRFile>`;
        const xmlBlob = new Blob([finalXml], { type:'application/xml' });
        results.innerHTML = `<h5>XML Generated</h5><button id="dlXml" class="btn btn-success mb-2">Download SDRFile.xml</button><pre class="xml-preview">${escapeXml(finalXml)}</pre>`;
        document.getElementById('dlXml').addEventListener('click', ()=> downloadBlob(xmlBlob,'SDRFile.xml'));
        results.classList.remove('hidden');
        output.textContent = `Converted ${rows.length} rows.`;
        renderFileList();
        return;
      }

      // VERIFY mode — pick one Excel and one PDF (simple flow)
      const excelItem = allowed.find(x => x.type === 'excel' || x.file.name.toLowerCase().endsWith('.csv') || x.file.name.toLowerCase().endsWith('.xlsx') || x.file.name.toLowerCase().endsWith('.xls'));
      const pdfItem = allowed.find(x => x.type === 'pdf' || x.file.name.toLowerCase().endsWith('.pdf'));
      if (!excelItem || !pdfItem) throw new Error('Please provide one Excel/CSV and one PDF file for matching.');

      // Read Excel
      const excelRaw = await readExcelFile(excelItem.file);
      if (!excelRaw || excelRaw.length < 2) throw new Error('Excel must have header + data rows.');
      const headersA = excelRaw[0].map(c => String(c || '').trim());
      const rowsA = excelRaw.slice(1).map(r => r.map(c => c===undefined||c===null ? '' : c));

      // PDF text extraction (requires pdf.js). If not present, instruct user
      let headersB = [], rowsB = [];
      let pdfText = '';
      if (typeof pdfjsLib !== 'undefined' && pdfjsLib.getDocument) {
        try {
          const ab = await pdfItem.file.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: ab }).promise;
          const parts = [];
          for (let p=1;p<=pdf.numPages;p++){
            const page = await pdf.getPage(p);
            const content = await page.getTextContent();
            parts.push(content.items.map(i=>i.str).join(' '));
          }
          pdfText = parts.join('\n').trim();
        } catch(e) { pdfText = ''; }
      } else {
        // If pdf.js not loaded, we prefer user to upload CSV/Excel extracted from PDF
        throw new Error('PDF parsing is not available in-browser. Please include pdf.js or upload a machine-readable table (CSV/Excel) extracted from the PDF.');
      }

      if (pdfText) {
        const lines = pdfText.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
        const splitted = lines.map(l => l.split(/\s{2,}|\t|\|/).map(c => c.trim()).filter(Boolean));
        const detectHeaderRow = (arr) => {
          for (let i=0;i<arr.length;i++) {
            const low = arr[i].map(s => (s||'').toLowerCase());
            if (low.some(c => /account|លេខគណនី|លេខ|account number|accountno/.test(c)) || low.some(c=>/amount|ចំនួន|amount transfer|total/.test(c))) return i;
          }
          return 0;
        };
        const headerRowIndex = detectHeaderRow(splitted);
        headersB = splitted[headerRowIndex];
        rowsB = splitted.slice(headerRowIndex+1);
      }

      // Run matching
      const matchResult = matchSources(headersA, rowsA, headersB, rowsB);
      if (!matchResult.ok) {
        // show diagnostics but keep UI interactive
        results.innerHTML = `<div class="alert alert-warning">Column detection failed. Diagnostics:<pre>${escapeXml(JSON.stringify(matchResult.diagnostics || {}, null, 2))}</pre></div>`;
        results.classList.remove('hidden');
        output.textContent = 'Column detection failed. See diagnostics above.';
        return;
      }

      // Present summary
      const summary = `Matches: ${matchResult.matches.length}\nUnmatched Excel: ${matchResult.unmatchedLeft.length}\nUnmatched PDF: ${matchResult.unmatchedRight.length}\n`;
      let sample = '';
      matchResult.matches.slice(0,10).forEach(m => { sample += `Left[${m.leftIndex}] ↔ Right[${m.rightIndex}] (${m.reason})\n`; });
      results.innerHTML = `<h5>Verification Result</h5><pre>${escapeXml(summary + '\n' + sample)}</pre>`;
      results.classList.remove('hidden');
      output.textContent = summary;

    } catch(err) {
      output.textContent = `An Error Occurred:\n${err && err.message ? err.message : String(err)}`;
      results.classList.remove('hidden');
      results.innerHTML = `<div class="alert alert-danger">Error: ${escapeXml(err && err.message ? err.message : String(err))}</div>`;
    } finally {
      loader.classList.add('hidden');
      renderFileList();
    }
  });

  // Expose matchSources so internal call can return diagnostics when detection fails
  function matchSources(headersA, rowsA, headersB, rowsB) {
    // If detection fails, return diagnostics object instead of throwing
    const detection = detectAccountAndAmountIndices(headersA, rowsA, headersB, rowsB);
    if (!detection.ok) return { ok:false, diagnostics: detection.diagnostics };

    // else do the matching
    const accIdxA = detection.accIdxLeft, amtIdxA = detection.amtIdxLeft, accIdxB = detection.accIdxRight, amtIdxB = detection.amtIdxRight;

    const prep = prepareSerialColumns(headersA, rowsA, headersB, rowsB);
    const Lrows = prep.leftRows, Rrows = prep.rightRows, LserialIdx = prep.leftSerialIndex, RserialIdx = prep.rightSerialIndex;

    const rightBySerial = new Map();
    for (let j=0;j<Rrows.length;j++){
      const key = (Rrows[j][RserialIdx]||'').toString().trim();
      if (!rightBySerial.has(key)) rightBySerial.set(key, []);
      rightBySerial.get(key).push({ row:Rrows[j], index:j });
    }

    const matches = [], unmatchedLeft = [], unmatchedRightUsed = new Set();

    for (let i=0;i<Lrows.length;i++){
      const Lrow = Lrows[i];
      const serialKey = (Lrow[LserialIdx]||'').toString().trim();
      let matched = false;

      if (serialKey !== '' && rightBySerial.has(serialKey)) {
        const cands = rightBySerial.get(serialKey);
        let chosen = null;
        for (const c of cands) {
          const rAmt = Rrows[c.index][amtIdxB];
          const lAmt = Lrow[amtIdxA];
          if (amtIdxA >=0 && amtIdxB >=0 && compareAmounts(lAmt, rAmt)) { chosen = c; break; }
        }
        if (!chosen) chosen = cands.find(c => !unmatchedRightUsed.has(c.index)) || cands[0];
        matches.push({ leftIndex:i, rightIndex:chosen.index, leftRow:Lrow, rightRow:chosen.row, reason:'serial' });
        unmatchedRightUsed.add(chosen.index);
        matched = true;
      }

      if (!matched) {
        const lAcc = accIdxA >= 0 ? String(Lrow[accIdxA] || '').replace(/\s+/g,'') : '';
        const lAmt = amtIdxA >= 0 ? Lrow[amtIdxA] : '';
        let bestCandidate = null;
        for (let j=0;j<Rrows.length;j++){
          if (unmatchedRightUsed.has(j)) continue;
          const Rrow = Rrows[j];
          const rAcc = accIdxB >= 0 ? String(Rrow[accIdxB] || '').replace(/\s+/g,'') : '';
          const rAmt = amtIdxB >= 0 ? Rrow[amtIdxB] : '';
          const accMatch = lAcc && rAcc ? (lAcc === rAcc) : true;
          const amtMatch = (amtIdxA >=0 && amtIdxB >=0) ? compareAmounts(lAmt, rAmt) : true;
          if (accMatch && amtMatch) { bestCandidate = { index:j, row:Rrow }; break; }
        }
        if (bestCandidate) { matches.push({ leftIndex:i, rightIndex:bestCandidate.index, leftRow:Lrow, rightRow:bestCandidate.row, reason:'fuzzy' }); unmatchedRightUsed.add(bestCandidate.index); matched = true; }
      }

      if (!matched) unmatchedLeft.push({ index:i, row:Lrow });
    }

    const unmatchedRight = [];
    for (let j=0;j<Rrows.length;j++) if (!unmatchedRightUsed.has(j)) unmatchedRight.push({ index:j, row:Rrows[j] });

    return { ok:true, matches, unmatchedLeft, unmatchedRight };
  }

  // Expose functions used above in-case you want to call them elsewhere
  window.detectAccountAndAmountIndices = detectAccountAndAmountIndices;
  window.normalizeAmountToNumber = normalizeAmountToNumber;
  window.compareAmounts = compareAmounts;

</script>

<!-- Optional libraries you can enable by uncommenting -->
<!-- <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script> -->
<!--
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.172/pdf.min.js"></script>
<script>pdfjsLib = window['pdfjs-dist/build/pdf'];</script>
-->

</body>
</html>
```
