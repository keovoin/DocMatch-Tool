<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DocMatch Tool ‚Äì Compare & Convert (Local + AI Optional)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; }
    h1 { color: #2c3e50; margin-bottom: 0.25rem; }
    small { color: #666; }
    section { margin: 2rem 0; }
    input, button { margin: 0.5rem 0; }
    button { padding: 0.5rem 1rem; cursor: pointer; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    pre, .box { background: #f7f7f8; padding: 1rem; border: 1px solid #e2e2e4; border-radius: 8px; }
    .diff { white-space: pre-wrap; max-height: 360px; overflow-y: auto; }
    .ok { color: #2e7d32; }
    .bad { color: #c62828; }
    .tag { display: inline-block; padding: 0.2rem 0.5rem; background: #eef; border: 1px solid #cce; border-radius: 6px; margin-right: 0.5rem; }
    table { width: 100%; border-collapse: collapse; }
    td, th { border: 1px solid #ddd; padding: 6px; font-size: 14px; }
    tr.mismatch { background: #fff3f3; }
    tr.match { background: #f3fff3; }
  </style>
</head>
<body>
  <h1>üìë DocMatch Tool</h1>
  <small>Local comparison and XML conversion run entirely in your browser. Optional AI compare calls your private proxy (no keys in the page).</small>

  <!-- Config -->
  <section>
    <h2>Configuration</h2>
    <div class="box">
      <label for="apiUrl"><span class="tag">Optional</span> Perplexity proxy API URL</label><br>
      <input id="apiUrl" type="text" placeholder="https://your-proxy.example.com/api/compare" style="width:100%;">
      <small>Leave blank to disable AI compare. If set, we‚Äôll send extracted text (not files) to your proxy.</small>
    </div>
  </section>

  <!-- Excel Comparison -->
  <section>
    <h2>Compare Excel (.xlsx)</h2>
    <div class="grid">
      <div>
        <input type="file" id="excel1" accept=".xlsx" />
        <input type="file" id="excel2" accept=".xlsx" /><br>
        <button onclick="compareExcel()">Compare Excel (Local)</button>
        <button onclick="aiCompareExcel()">AI Compare (Proxy)</button>
      </div>
      <div class="box">
        <div id="excelSummary"></div>
        <div class="diff" id="excelOutput"></div>
      </div>
    </div>
  </section>

  <!-- PDF Comparison -->
  <section>
    <h2>Compare PDF (.pdf)</h2>
    <div class="grid">
      <div>
        <input type="file" id="pdf1" accept=".pdf" />
        <input type="file" id="pdf2" accept=".pdf" /><br>
        <button onclick="comparePDF()">Compare PDF (Local)</button>
        <button onclick="aiComparePDF()">AI Compare (Proxy)</button>
      </div>
      <div class="box">
        <div id="pdfSummary"></div>
        <div class="diff" id="pdfOutput"></div>
      </div>
    </div>
  </section>

  <!-- Extract & Convert to XML -->
  <section>
    <h2>Extract & Convert to XML</h2>
    <div class="grid">
      <div>
        <input type="file" id="xmlFile" accept=".xlsx,.pdf" /><br>
        <button onclick="convertToXML()">Convert to XML (Local)</button>
        <button onclick="downloadXML()">Download XML</button>
      </div>
      <pre id="xmlOutput" class="box"></pre>
    </div>
  </section>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

  <script>
    // ---------- Helpers ----------
    function escapeXml(unsafe) {
      return String(unsafe ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;");
    }

    function downloadText(filename, text) {
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      URL.revokeObjectURL(url);
      a.remove();
    }

    // ---------- Excel ----------
    async function readExcel(file) {
      const data = await file.arrayBuffer();
      const workbook = XLSX.read(data);
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      return XLSX.utils.sheet_to_json(sheet, { header: 1 }); // rows: array of arrays
    }

    function excelToXML(data) {
      let xml = "<Workbook>\n";
      data.forEach((row, i) => {
        xml += `  <Row index="${i+1}">\n`;
        row.forEach((cell, j) => {
          xml += `    <Cell col="${j+1}">${escapeXml(cell)}</Cell>\n`;
        });
        xml += "  </Row>\n";
      });
      xml += "</Workbook>";
      return xml;
    }

    function renderExcelDiff(d1, d2) {
      const table = document.createElement("table");
      const maxRows = Math.max(d1.length, d2.length);
      const maxCols = Math.max(
        ...[d1, d2].map(d => d.reduce((m, r) => Math.max(m, r.length), 0))
      );
      const header = table.createTHead().insertRow();
      ["Row", ...Array.from({ length: maxCols }, (_, i) => `Col ${i+1}`)].forEach(h => {
        const th = document.createElement("th"); th.textContent = h; header.appendChild(th);
      });
      const tbody = table.createTBody();
      let mismatchCount = 0;

      for (let i = 0; i < maxRows; i++) {
        const row = tbody.insertRow();
        const ri = document.createElement("td"); ri.textContent = i+1; row.appendChild(ri);
        let rowMismatch = false;

        for (let j = 0; j < maxCols; j++) {
          const a = d1[i]?.[j] ?? "";
          const b = d2[i]?.[j] ?? "";
          const td = document.createElement("td");
          if (a === b) {
            td.textContent = a;
            td.classList.add("match");
          } else {
            td.innerHTML = `<span class="bad">${escapeXml(a)}</span> vs <span class="ok">${escapeXml(b)}</span>`;
            td.classList.add("mismatch");
            rowMismatch = true;
            mismatchCount++;
          }
          row.appendChild(td);
        }
        if (rowMismatch) row.classList.add("mismatch");
      }

      document.getElementById("excelSummary").innerHTML =
        mismatchCount === 0
          ? '<span class="ok">‚úÖ No differences found</span>'
          : `<span class="bad">‚ö†Ô∏è ${mismatchCount} mismatches detected</span>`;
      const out = document.getElementById("excelOutput");
      out.innerHTML = "";
      out.appendChild(table);
    }

    async function compareExcel() {
      const f1 = document.getElementById("excel1").files[0];
      const f2 = document.getElementById("excel2").files[0];
      if (!f1 || !f2) return alert("Please upload both Excel files");

      const [d1, d2] = await Promise.all([readExcel(f1), readExcel(f2)]);
      renderExcelDiff(d1, d2);
    }

    async function aiCompareExcel() {
      const f1 = document.getElementById("excel1").files[0];
      const f2 = document.getElementById("excel2").files[0];
      const apiUrl = document.getElementById("apiUrl").value.trim();
      if (!f1 || !f2) return alert("Upload both Excel files");
      if (!apiUrl) return alert("Set your Perplexity proxy API URL first.");

      const [d1, d2] = await Promise.all([readExcel(f1), readExcel(f2)]);
      // Convert to simple text blocks for semantic comparison
      const textA = d1.map(r => r.join(" | ")).join("\n");
      const textB = d2.map(r => r.join(" | ")).join("\n");

      const instructions = "Focus on headers, approval levels, numeric thresholds, and multilingual (Khmer/English) mismatches. Produce a compact table.";
      const resp = await fetch(apiUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ docA: textA, docB: textB, instructions })
      });
      const json = await resp.json();
      document.getElementById("excelSummary").innerHTML = '<span class="tag">AI result</span>';
      document.getElementById("excelOutput").textContent = json.result || JSON.stringify(json, null, 2);
    }

    // ---------- PDF ----------
    async function extractPdfLines(file) {
      const data = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data }).promise;
      let lines = [];
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const text = content.items.map(it => it.str).join(" ").trim();
        lines.push(text);
      }
      return lines;
    }

    function pdfTextToXML(lines) {
      let xml = "<PDF>\n";
      lines.forEach((line, i) => {
        xml += `  <Line index="${i+1}">${escapeXml(line)}</Line>\n`;
      });
      xml += "</PDF>";
      return xml;
    }

    async function comparePDF() {
      const f1 = document.getElementById("pdf1").files[0];
      const f2 = document.getElementById("pdf2").files[0];
      if (!f1 || !f2) return alert("Please upload both PDFs");

      const [t1, t2] = await Promise.all([extractPdfLines(f1), extractPdfLines(f2)]);
      let mismatches = 0;
      const out = document.getElementById("pdfOutput");
      out.innerHTML = "";

      const table = document.createElement("table");
      const header = table.createTHead().insertRow();
      ["Line", "Doc A", "Doc B"].forEach(h => {
        const th = document.createElement("th"); th.textContent = h; header.appendChild(th);
      });
      const tbody = table.createTBody();
      const max = Math.max(t1.length, t2.length);

      for (let i = 0; i < max; i++) {
        const a = t1[i] ?? "";
        const b = t2[i] ?? "";
        const row = tbody.insertRow();
        const li = row.insertCell(); li.textContent = i+1;

        const ca = row.insertCell();
        const cb = row.insertCell();
        if (a.trim() === b.trim()) {
          ca.textContent = a; cb.textContent = b;
          row.classList.add("match");
        } else {
          ca.innerHTML = `<span class="bad">${escapeXml(a)}</span>`;
          cb.innerHTML = `<span class="ok">${escapeXml(b)}</span>`;
          row.classList.add("mismatch");
          mismatches++;
        }
      }

      document.getElementById("pdfSummary").innerHTML =
        mismatches === 0
          ? '<span class="ok">‚úÖ No differences found</span>'
          : `<span class="bad">‚ö†Ô∏è ${mismatches} mismatches detected</span>`;
      out.appendChild(table);
    }

    async function aiComparePDF() {
      const f1 = document.getElementById("pdf1").files[0];
      const f2 = document.getElementById("pdf2").files[0];
      const apiUrl = document.getElementById("apiUrl").value.trim();
      if (!f1 || !f2) return alert("Upload both PDFs");
      if (!apiUrl) return alert("Set your Perplexity proxy API URL first.");

      const [t1, t2] = await Promise.all([extractPdfLines(f1), extractPdfLines(f2)]);
      const textA = t1.join("\n");
      const textB = t2.join("\n");

      const instructions = "Compare SOPs semantically. Flag missing steps, policy gaps, and header inconsistencies. Return a compact table.";
      const resp = await fetch(apiUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ docA: textA, docB: textB, instructions })
      });
      const json = await resp.json();
      document.getElementById("pdfSummary").innerHTML = '<span class="tag">AI result</span>';
      document.getElementById("pdfOutput").textContent = json.result || JSON.stringify(json, null, 2);
    }

    // ---------- XML ----------
    async function convertToXML() {
      const file = document.getElementById("xmlFile").files[0];
      if (!file) return alert("Please upload a file");

      let xml = "";
      if (file.name.endsWith(".xlsx")) {
        const data = await readExcel(file);
        xml = excelToXML(data);
      } else if (file.name.endsWith(".pdf")) {
        const lines = await extractPdfLines(file);
        xml = pdfTextToXML(lines);
      } else {
        return alert("Unsupported file type");
      }
      document.getElementById("xmlOutput").textContent = xml;
    }

    function downloadXML() {
      const xml = document.getElementById("xmlOutput").textContent.trim();
      if (!xml) return alert("No XML to download. Convert first.");
      downloadText("docmatch.xml", xml);
    }
  </script>
</body>
</html>
