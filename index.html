<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DocMatch Tool – Header‑Agnostic Matching (EN/KH)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#f6f7fb; --card:#ffffff; --text:#1a1a1a; --muted:#6b7280;
      --primary:#0067c0; --primary-600:#045aa6;
      --border:#e5e7eb; --ok:#0f766e; --warn:#b45309; --danger:#b91c1c;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans", "Khmer UI",
                   "Battambang","Noto Sans Khmer", Arial, sans-serif;
      line-height:1.5;
    }
    .container{max-width:1100px; margin:32px auto; padding:0 20px;}
    h1{margin:0 0 6px 0; font-size:1.65rem}
    .sub{color:var(--muted)}
    .card{background:var(--card); border:1px solid var(--border); border-radius:12px; padding:16px}
    .grid{display:grid; gap:12px}
    .grid.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
    label{font-weight:600; display:block; margin-bottom:6px}
    input[type=file]{
      width:100%; padding:10px; border:1px dashed var(--border); border-radius:8px; background:#fafafa;
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .btn{border:0; border-radius:8px; padding:10px 14px; font-weight:600; cursor:pointer; background:var(--primary); color:#fff;}
    .btn:hover{background:var(--primary-600)}
    .btn.secondary{background:#eef2ff; color:#1f2937}
    .btn.secondary:hover{background:#e5e7ff}
    .btn:disabled{opacity:.6; cursor:not-allowed}
    .status{color:var(--muted)}
    .status.ok{color:var(--ok); font-weight:600}
    .status.error{color:var(--danger); font-weight:600}
    .status.warn{color:var(--warn); font-weight:600}
    .note{background:#fff7ed; color:#7c2d12; border:1px solid #ffedd5; border-radius:8px; padding:10px}
    .table-wrap{overflow:auto; margin-top:12px}
    table{border-collapse:collapse; width:100%; font-size:.96rem}
    th, td{border-bottom:1px solid var(--border); padding:8px 10px; text-align:left; white-space:nowrap}
    th{background:#fafafa; position:sticky; top:0; z-index:1}
    tr.diff{background:#fff9f0}
    tr.zero{background:#f7fff9}
    .totals{display:flex; gap:8px; flex-wrap:wrap; margin:10px 0}
    .pill{border:1px solid var(--border); background:#fff; border-radius:999px; padding:6px 10px}
    code{background:#f3f4f6; border:1px solid var(--border); border-radius:6px; padding:2px 6px}
    footer{margin:26px 0 8px 0; color:var(--muted); font-size:.92rem}
  </style>

  <!-- Parsers -->
  https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js</script>
  https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js</script>
</head>
<body>
  <div class="container">
    <header>
      <h1>DocMatch – Header‑Agnostic Verification</h1>
      <div class="sub">Upload two files (CSV/XLSX). The tool auto‑infers <strong>Account</strong> & <strong>Amount</strong> purely by content (English, Khmer, mixed). No header validation.</div>
    </header>

    <section class="card">
      <div class="grid cols-2">
        <div>
          <label for="fileA">File A (CSV/XLSX) – ឯកសារ A</label>
          <input id="fileA" type="file" accept=".csv,.xlsx,.xls" />
          <div id="infoA" class="status"></div>
        </div>
        <div>
          <label for="fileB">File B (CSV/XLSX) – ឯកសារ B</label>
          <input id="fileB" type="file" accept=".csv,.xlsx,.xls" />
          <div id="infoB" class="status"></div>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <button id="btnVerify" class="btn" type="button">Verify / ផ្ទៀងផ្ទាត់</button>
        <button id="btnReset" class="btn secondary" type="button">Reset</button>
        <button id="btnExport" class="btn secondary" type="button" disabled>Export CSV</button>
        <span id="status" class="status"></span>
      </div>

      <div id="hint" class="note" style="margin-top:12px; display:none;"></div>

      <div class="totals" id="totals" style="display:none"></div>

      <div class="table-wrap" id="tableWrap" style="display:none">
        <table id="resultTable" aria-label="Comparison results">
          <thead>
            <tr>
              <th>#</th>
              <th>Account / គណនី</th>
              <th>Amount A</th>
              <th>Amount B</th>
              <th>Diff (A - B)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div id="debug" class="status" style="margin-top:8px"></div>
    </section>

    <footer>
      Supports currency symbols (USD/KHR/៛), commas, spaces, and negatives in parentheses.
    </footer>
  </div>

  <script>
    // ------------------ DOM helpers ------------------
    const $ = (sel, root=document) => root.querySelector(sel);
    const fileAEl = $('#fileA'), fileBEl = $('#fileB');
    const infoAEl = $('#infoA'), infoBEl = $('#infoB');
    const btnVerify = $('#btnVerify'), btnReset = $('#btnReset'), btnExport = $('#btnExport');
    const statusEl = $('#status'), hintEl = $('#hint'), totalsEl = $('#totals'), tableWrapEl = $('#tableWrap');
    const resultTableEl = $('#resultTable'), debugEl = $('#debug');

    let lastRows = [];

    // ------------------ File info ------------------
    function getFileInfo(f) {
      if (!f) return '';
      const kb = Math.round(f.size/1024);
      return `${f.name} • ${kb} KB`;
    }
    fileAEl.addEventListener('change', () => { infoAEl.textContent = getFileInfo(fileAEl.files?.[0]); });
    fileBEl.addEventListener('change', () => { infoBEl.textContent = getFileInfo(fileBEl.files?.[0]); });

    // ------------------ CSV parse ------------------
    function parseCSV(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: 'greedy',
          dynamicTyping: false,
          complete: (res) => {
            const headers = res.meta.fields || Object.keys(res.data?.[0] || {});
            resolve({ headers, rows: res.data.map(r => r || {}) });
          },
          error: err => reject(err)
        });
      });
    }

    // ------------------ Excel parse (header-agnostic) ------------------
    function isNumericLike(s) {
      if (s == null) return false;
      const t = String(s)
        .replace(/[៛$€£]|usd|khr|riel/gi, "")
        .replace(/[,\s]/g, "")
        .replace(/[()]/g, "")
        .trim();
      if (!t || /^[-.]+$/.test(t)) return false;
      const num = Number(t);
      return Number.isFinite(num);
    }

    function findHeaderRowIndex(rows2D, lookahead = 15) {
      // Prefer rows with mostly text cells and reasonable non-empty count
      let best = { idx: 0, score: -1 };
      const lim = Math.min(lookahead, rows2D.length);
      for (let i = 0; i < lim; i++) {
        const r = rows2D[i] || [];
        let nonEmpty = 0, texty = 0;
        for (const c of r) {
          if (c == null) continue;
          const s = String(c).trim(); if (!s) continue;
          nonEmpty++;
          if (!isNumericLike(s)) texty++;
        }
        const score = nonEmpty ? (texty / nonEmpty) + nonEmpty * 0.02 : 0;
        if (score > best.score) best = { idx: i, score };
      }
      return best.idx;
    }

    function parseXLSX(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload = (e) => {
          try {
            const data = new Uint8Array(e.target.result);
            const wb = XLSX.read(data, { type: 'array' });
            const sheetName = wb.SheetNames[0];
            const ws = wb.Sheets[sheetName];
            const rows2D = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false });
            if (!rows2D.length) return resolve({ headers: [], rows: [] });

            const headerIdx = findHeaderRowIndex(rows2D);
            const headersRaw = rows2D[headerIdx] || [];
            const headers = headersRaw.map((h, i) => {
              const txt = (h == null ? "" : String(h).trim());
              return txt || `Col${i+1}`;
            });

            const body = rows2D.slice(headerIdx + 1);
            const rows = body.map(r => {
              const obj = {};
              for (let i = 0; i < headers.length; i++) obj[headers[i]] = r[i];
              return obj;
            });

            resolve({ headers, rows });
          } catch (err) {
            reject(err);
          }
        };
        reader.readAsArrayBuffer(file);
      });
    }

    async function parseFile(file) {
      if (!file) return { headers: [], rows: [] };
      const ext = file.name.toLowerCase().split('.').pop();
      if (ext === 'csv') return parseCSV(file);
      if (ext === 'xlsx' || ext === 'xls') return parseXLSX(file);
      throw new Error(`Unsupported file type: ${ext}. Please use CSV or XLSX.`);
    }

    // ------------------ Header-agnostic inference ------------------
    function autoInferColumns(headers, rows) {
      const sample = rows.slice(0, 200); // limit for speed
      const stats = headers.map((h, i) => {
        let nonEmpty = 0, numeric = 0;
        const uniq = new Set();
        for (const r of sample) {
          const v = r[h];
          if (v == null) continue;
          const s = String(v).trim();
          if (!s) continue;
          nonEmpty++;
          if (isNumericLike(s)) numeric++;
          uniq.add(s);
        }
        const numericRatio = nonEmpty ? numeric / nonEmpty : 0;
        const uniqRatio = nonEmpty ? (uniq.size / nonEmpty) : 0;
        return { header: h, idx: i, nonEmpty, numericRatio, uniqRatio };
      });

      // Account: texty (low numericRatio), many unique values
      const acc = [...stats]
        .filter(c => c.nonEmpty > 0)
        .sort((a, b) =>
          (a.numericRatio - b.numericRatio) || (b.uniqRatio - a.uniqRatio) || (a.idx - b.idx)
        )[0] || { header: headers[0] };

      // Amount: numeric (high numericRatio)
      const amt = [...stats]
        .filter(c => c.nonEmpty > 0)
        .sort((a, b) =>
          (b.numericRatio - a.numericRatio) || (a.idx - b.idx)
        )[0] || { header: headers[1] || headers[0] };

      // Ensure different columns when possible
      if (acc.header === amt.header) {
        const alt = headers.find(h => h !== acc.header) || acc.header;
        return { accountHeader: acc.header, amountHeader: alt, mode: "auto" };
      }
      return { accountHeader: acc.header, amountHeader: amt.header, mode: "auto" };
    }

    // ------------------ Amount parsing & matching ------------------
    function parseAmount(s) {
      if (s == null) return NaN;
      const str = String(s);
      const neg = /\(.*\)/.test(str);
      const cleaned = str
        .replace(/[៛$€£]|usd|khr|riel/gi, "")
        .replace(/[,\s]/g, "")
        .replace(/[()]/g, "");
      const num = Number(cleaned);
      if (!Number.isFinite(num)) return NaN;
      return neg ? -Math.abs(num) : num;
    }

    function aggregateByAccount(rows, accountHeader, amountHeader) {
      const out = new Map();
      for (const r of rows) {
        const key = String(r[accountHeader] ?? "").trim();
        if (!key) continue;
        const amt = parseAmount(String(r[amountHeader] ?? ""));
        if (!Number.isFinite(amt)) continue;
        out.set(key, (out.get(key) ?? 0) + amt);
      }
      return out;
    }

    function compareMaps(mapA, mapB) {
      const all = new Set([...mapA.keys(), ...mapB.keys()]);
      const result = [];
      for (const k of all) {
        const a = mapA.get(k) ?? 0;
        const b = mapB.get(k) ?? 0;
        result.push({ account: k, amountA: a, amountB: b, diff: +(a - b).toFixed(2) });
      }
      result.sort((x, y) => Math.abs(y.diff) - Math.abs(x.diff) || x.account.localeCompare(y.account));
      return result;
    }

    async function verifyTwoFiles(tableA, tableB) {
      // Auto-infer columns (no validation, no prompts)
      const selA = autoInferColumns(tableA.headers, tableA.rows);
      const selB = autoInferColumns(tableB.headers, tableB.rows);

      const mapA = aggregateByAccount(tableA.rows, selA.accountHeader, selA.amountHeader);
      const mapB = aggregateByAccount(tableB.rows, selB.accountHeader, selB.amountHeader);

      const result = compareMaps(mapA, mapB);
      return { result, selA, selB };
    }

    // ------------------ UI: render & export ------------------
    function formatNumber(n) {
      return n.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }

    function renderResults(rows) {
      const tbody = resultTableEl.querySelector('tbody');
      tbody.innerHTML = "";
      let totalA = 0, totalB = 0, totalDiff = 0;

      rows.forEach((r, i) => {
        totalA += r.amountA; totalB += r.amountB; totalDiff += r.diff;
        const tr = document.createElement('tr');
        tr.className = (Math.abs(r.diff) > 0.005) ? 'diff' : 'zero';
        tr.innerHTML = `
          <td>${i+1}</td>
          <td>${escapeHTML(r.account)}</td>
          <td>${formatNumber(r.amountA)}</td>
          <td>${formatNumber(r.amountB)}</td>
          <td><strong>${formatNumber(r.diff)}</strong></td>
        `;
        tbody.appendChild(tr);
      });

      totalsEl.style.display = 'flex';
      totalsEl.innerHTML = `
        <div class="pill">Total A: <strong>${formatNumber(totalA)}</strong></div>
        <div class="pill">Total B: <strong>${formatNumber(totalB)}</strong></div>
        <div class="pill">Total Diff: <strong>${formatNumber(totalDiff)}</strong></div>
        <div class="pill">Rows: <strong>${rows.length}</strong></div>
      `;

      tableWrapEl.style.display = 'block';
      btnExport.disabled = rows.length === 0;
    }

    function escapeHTML(s) {
      return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
    }

    function exportCSV(rows) {
      const header = ["Account","Amount A","Amount B","Diff (A-B)"];
      const lines = [header.join(",")];
      for (const r of rows) {
        lines.push([
          `"${String(r.account).replace(/"/g,'""')}"`,
          r.amountA, r.amountB, r.diff
        ].join(","));
      }
      const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `DocMatch_Results_${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}.csv`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ------------------ Events ------------------
    btnExport.addEventListener('click', () => { if (lastRows?.length) exportCSV(lastRows); });

    btnReset.addEventListener('click', () => {
      fileAEl.value = ""; fileBEl.value = "";
      infoAEl.textContent = ""; infoBEl.textContent = "";
      statusEl.textContent = ""; statusEl.className = "status";
      hintEl.style.display = 'none'; hintEl.textContent = "";
      totalsEl.style.display = 'none'; totalsEl.innerHTML = "";
      tableWrapEl.style.display = 'none';
      resultTableEl.querySelector('tbody').innerHTML = "";
      debugEl.textContent = "";
      btnExport.disabled = true;
      lastRows = [];
    });

    btnVerify.addEventListener('click', async () => {
      const fA = fileAEl.files?.[0];
      const fB = fileBEl.files?.[0];
      if (!fA || !fB) {
        statusEl.textContent = "Please choose both files.";
        statusEl.className = "status error";
        return;
      }

      btnVerify.disabled = true;
      statusEl.textContent = "Parsing…"; statusEl.className = "status";
      hintEl.style.display = 'none'; hintEl.textContent = "";

      try {
        const [tA, tB] = await Promise.all([parseFile(fA), parseFile(fB)]);
        statusEl.textContent = "Matching…";
        const { result, selA, selB } = await verifyTwoFiles(tA, tB);

        lastRows = result;
        renderResults(result);
        statusEl.textContent = "Done.";
        statusEl.className = "status ok";

        // non-blocking info: which columns were auto-selected
        hintEl.style.display = 'block';
        hintEl.innerHTML = `
          <strong>Auto‑selected columns (no validation)</strong><br/>
          File A: Account=<code>${selA.accountHeader}</code>, Amount=<code>${selA.amountHeader}</code><br/>
          File B: Account=<code>${selB.accountHeader}</code>, Amount=<code>${selB.amountHeader}</code>
        `;
        debugEl.textContent = "";
      } catch (err) {
        console.error(err);
        statusEl.textContent = `An Error Occurred: ${err.message}`;
        statusEl.className = "status error";
      } finally {
        btnVerify.disabled = false;
      }
    });
  </script>
</body>
</html>
